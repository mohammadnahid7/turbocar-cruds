// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: messages.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	zero "gopkg.in/guregu/null.v4/zero"
)

const checkMessageOwnership = `-- name: CheckMessageOwnership :one
SELECT EXISTS (
    SELECT 1 FROM messages 
    WHERE id = $1 AND (sender_id = $2 OR recipient_id = $2)
) AS is_owner
`

type CheckMessageOwnershipParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) CheckMessageOwnership(ctx context.Context, arg CheckMessageOwnershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkMessageOwnership, arg.ID, arg.UserID)
	var is_owner bool
	err := row.Scan(&is_owner)
	return is_owner, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (sender_id, recipient_id, content)
VALUES ($1, $2, $3)
RETURNING id, sender_id, recipient_id, content, read, created_at, updated_at
`

type CreateMessageParams struct {
	SenderID    pgtype.UUID `json:"sender_id"`
	RecipientID pgtype.UUID `json:"recipient_id"`
	Content     zero.String `json:"content"`
}

type CreateMessageRow struct {
	ID          string             `json:"id"`
	SenderID    string             `json:"sender_id"`
	RecipientID string             `json:"recipient_id"`
	Content     string             `json:"content"`
	Read        pgtype.Bool        `json:"read"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (CreateMessageRow, error) {
	row := q.db.QueryRow(ctx, createMessage, arg.SenderID, arg.RecipientID, arg.Content)
	var i CreateMessageRow
	err := row.Scan(
		&i.ID,
		&i.SenderID,
		&i.RecipientID,
		&i.Content,
		&i.Read,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages WHERE id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessage, id)
	return err
}

const getMessagesByUser = `-- name: GetMessagesByUser :many
SELECT 
    CASE 
        WHEN sender_id = $1 THEN recipient_id
        ELSE sender_id
    END AS user_id,
    json_agg(
        json_build_object(
            'id', id,
            'sender_id', sender_id,
            'recipient_id', recipient_id,
            'content', content,
            'read', read,
            'created_at', created_at,
            'updated_at', updated_at
        ) ORDER BY created_at ASC
    ) AS messages
FROM messages
WHERE sender_id = $1 OR recipient_id = $1
GROUP BY user_id
`

type GetMessagesByUserRow struct {
	UserID   pgtype.UUID `json:"user_id"`
	Messages []byte      `json:"messages"`
}

func (q *Queries) GetMessagesByUser(ctx context.Context, userID pgtype.UUID) ([]GetMessagesByUserRow, error) {
	rows, err := q.db.Query(ctx, getMessagesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesByUserRow
	for rows.Next() {
		var i GetMessagesByUserRow
		if err := rows.Scan(&i.UserID, &i.Messages); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByUserAndId = `-- name: GetMessagesByUserAndId :many
SELECT 
    id,
    sender_id,
    recipient_id,
    content,
    read,
    created_at,
    updated_at
FROM messages
WHERE 
    (sender_id = $1 AND recipient_id = $2)
    OR 
    (sender_id = $2 AND recipient_id = $1)
ORDER BY created_at ASC
`

type GetMessagesByUserAndIdParams struct {
	User1ID pgtype.UUID `json:"user1_id"`
	User2ID pgtype.UUID `json:"user2_id"`
}

type GetMessagesByUserAndIdRow struct {
	ID          string             `json:"id"`
	SenderID    string             `json:"sender_id"`
	RecipientID string             `json:"recipient_id"`
	Content     string             `json:"content"`
	Read        pgtype.Bool        `json:"read"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetMessagesByUserAndId(ctx context.Context, arg GetMessagesByUserAndIdParams) ([]GetMessagesByUserAndIdRow, error) {
	rows, err := q.db.Query(ctx, getMessagesByUserAndId, arg.User1ID, arg.User2ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessagesByUserAndIdRow
	for rows.Next() {
		var i GetMessagesByUserAndIdRow
		if err := rows.Scan(
			&i.ID,
			&i.SenderID,
			&i.RecipientID,
			&i.Content,
			&i.Read,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMessageAsRead = `-- name: MarkMessageAsRead :exec
UPDATE messages
SET read = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) MarkMessageAsRead(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markMessageAsRead, id)
	return err
}
